1)func COUNTDOWN() {
	for i := '9'; i >= '0'; i-- {
		z01.PrintRune(i)
	}
	z01.PrintRune(10)
}
_________________________________
_________________________________

2)func FirstRune(s string) rune {

	cox := []rune(s)
	return cox[0]
}
_________________________________
3)func LastRune(s string) rune {
	m := 0
	ms := []rune(s)
	for range s {

		m++
	}
	return ms[m-1]

}____________________________
4)func ROT13() {
	arg := os.Args[1:]
	if len(arg) == 1 {
		massiv := []rune(arg[0])
		for i := 0; i < len(massiv); i++ {
			if massiv[i] >= 'a' && massiv[i] <= 'z' {
				if massiv[i] > 'm' {
					massiv[i] = massiv[i] - 13
				} else {
					massiv[i] = massiv[i] + 13
				}
			} else if massiv[i] >= 'A' && massiv[i] <= 'Z' {
				if massiv[i] > 'M' {
					massiv[i] = massiv[i] - 13
				} else {
					massiv[i] = massiv[i] + 13
				}
			}
		}
		for _, v := range massiv {
			z01.PrintRune(v)
		}

	}
	z01.PrintRune('\n')
}
_________________________________
5)func lastword() {
	argString := os.Args[1]
	var (
		indexTo, indexFrom int
		slice              string
	)
	lenArgString := len(argString) - 1
	for i := lenArgString; i >= 0; i-- {
		if indexTo == 0 && argString[i] != ' ' {
			indexTo = i + 1
		} else if indexTo > 0 && argString[i] == ' ' {
			indexFrom = i + 1
			break
		}
	}
	slice = arg[index2:index1]
	for _, v := range slice {
		z01.PrintRune(v)
	}

	slice = argString[indexFrom:indexTo]
	for _, v := range slice {
		z01.PrintRune(v)
	}
	z01.PrintRune('\n')

}___________________
6)func tabmult() {
    if len(os.Args[1:]) != 1 {
        z01.PrintRune('\n')
        return
    } else {
        a, _ := strconv.Atoi(os.Args[1])
        b := os.Args[1]
        if a < 0 {
            z01.PrintRune('\n')
            return
        }
        for i := 1; i <= 9; i++ {
            res := i * a
            z01.PrintRune(rune(i + 48))
            z01.PrintRune(' ')
            z01.PrintRune('x')
            z01.PrintRune(' ')
            for _, v := range b {
                z01.PrintRune(v)
            }
            z01.PrintRune(' ')
            z01.PrintRune('=')
            z01.PrintRune(' ')
            str := strconv.Itoa(res)
            for _, v := range str {
                z01.PrintRune(v)
            }
            z01.PrintRune('\n')

        }
    }
}
func Atoi(s string) int {
	len := 0
	for range s {
		len++
	}
	plus := 0
	minus := 0
	final := 0
	count := 0
	str := []rune(s)
	for i := 0; i < len; i++ {
		if str[i] >= '0' && str[i] <= '9' {
			count = 0
			for j := '0'; j < str[i]; j++ {
				count++
			}
			final = final*10 + count
		} else if str[i] == '-' && str[i] == 0 {
			minus++
		} else if str[i] == '+' && str[i] == 0 {
			plus++
		} else {
			return 0
		}

	}
	if minus == 1 {
		final = -final
	}
	return final
}
_________________________________
7)func ALPHAMIRROR() {
	input := os.Args[1]
	str := []rune(input)
	for i := range str {
		if !(str[i] >= 'a' && str[i] <= 'z') && !(str[i] >= 'A' && str[i] <= 'Z') {
			continue
		}
		if str[i] >= 'a' && str[i] <= 'm' {
			count := 25
			for j := 'a'; j < str[i]; j++ {
				count -= 2
			}
			str[i] = str[i] + rune(count)
		} else if str[i] >= 'n' && str[i] <= 'z' {
			count := 25
			for j := 'z'; j > str[i]; j-- {
				count -= 2
			}
			str[i] = str[i] - rune(count)
		} else if str[i] >= 'A' && str[i] <= 'M' {
			count := 25
			for j := 'A'; j < str[i]; j++ {
				count -= 2
			}
			str[i] = str[i] + rune(count)
		} else if str[i] >= 'N' && str[i] <= 'Z' {
			count := 25
			for j := 'Z'; j > str[i]; j-- {
				count -= 2
			}
			str[i] = str[i] - rune(count)
		}
	}

	for i := range str {
		z01.PrintRune(str[i])
	} else {
		z01.PrintRune(10)
	}	
}
_________________________________
8)func compare() {
    if len(os.Args[1:]) != 2 {
        z01.PrintRune('\n')
        return
    }
    a := os.Args[1]
    b := os.Args[2]
    c := 0
    if a < b {
        c = -1
    } else if a > b {
        c = 1
    }
    res := strconv.Itoa(c)
    for _, v := range res {
        z01.PrintRune(v)
    }
}
________________________
9)func DOOP() {
	func modulo(a, b int) int {
		return a % b
	}
	
	func divide(a, b int) int {
		if b == 0 {
			return 0
		}
		return a / b
	}
	
	func substract(a, b int) int {
		return a - b
	}
	
	func add(a, b int) int {
		return a + b
	}
	
	func multiply(a, b int) int {
		return a * b
	}
	
	func doop(a int, b int, op string) (int, string) {
		var res int
		switch op {
		case "+":
			res = add(a, b)
	
		case "-":
			res = substract(a, b)
	
		case "*":
			res = multiply(a, b)
	
		case "/":
			if b == 0 {
				return 0, "No division by 0"
			} else {
				res = divide(a, b)
			}
		case "%":
			if b == 0 {
				return 0, "No modulo by 0"
			} else {
				res = modulo(a, b)
			}
		}
		return res, ""
	}
	
	func main() {
	
		args := os.Args[1:]
	
		if len(args) == 0 {
			return
		} else if len(args) > 3 {
			fmt.Println(0)
		} else {
			a, Aerr := strconv.Atoi(args[0])
			if Aerr != nil {
				fmt.Println(0)
			} else {
				op := args[1]
				b, Berr := strconv.Atoi(args[2])
				if Berr != nil {
					fmt.Println(0)
				} else {
					res, err := doop(a, b, op)
					if len(err) > 0 {
						fmt.Println(err)
					} else {
						if a > 0 && b > 0 && res < 0 {
							fmt.Println(0)
						} else if a < 0 && b < 0 && res > 0 {
							fmt.Println(0)
						} else if a < 0 && b > 0 {
							fmt.Println(res)
						} else {
							fmt.Println(res)
						}
					}
				}
			}
		}
	}
func Atoi(s string) int {
	len := 0
	for range s {
		len++
	}
	plus := 0
	minus := 0
	final := 0
	count := 0
	str := []rune(s)
	for i := 0; i < len; i++ {
		if str[i] >= '0' && str[i] <= '9' {
			count = 0
			for j := '0'; j < str[i]; j++ {
				count++
			}
			final = final*10 + count
		} else if str[i] == '+' && i == 0 {
			plus++
		} else if str[i] == '-' && i == 0 {
			minus++
		} else {
			return 0
		}
	}

	if minus == 1 {
		final = -final
	}
	return final
}
_________________________________
10)func ISPOWEROF2() {
	arg := os.Args[1:]
	if len(arg) == 1 {
		x, err := strconv.Atoi(arg[0])
		if err != nil {
			fmt.Println(err.Error())
		} else if x != 0 && (x&(x-1)) == 0 {
			fmt.Println(true)
		} else {
			fmt.Println(false)
		}

	} else {
		fmt.Println()
	}
}
_________________________________
func ISPOWEROFF() {
	if len(os.Args) == 2 {
		x, err := strconv.Atoi(os.Args[1])
		if err != nil {
			fmt.Println(err.Error())
		} else {
			for x%2 == 0 {
				if x == 0 {
					break
				}
				x = x / 2
			}
			if x == 1 {
				fmt.Println(true)
			}
			if x == 0 || x != 1 {
				fmt.Println(false)
			}
		}
	} else {
		fmt.Println()
	}
}
_________________________________
11)func UNION() {
	if len(os.Args) == 3 {
		s1 := os.Args[1]
		s2 := os.Args[2]
		sum := s1 + s2
		mas := []rune(sum)
		for i := 0; i < len(mas); i++ {
			for k := i + 1; k < len(mas); k++ {
				if mas[i] == mas[k] {
					mas[k] = 0
				}
			}
		}
		fmt.Println(string(mas))

	} else {
		fmt.Println()
	}
}
_____________________________________
12)func INTER() {
	answer := ""
	if len(os.Args) == 3 {
		str1 := os.Args[1]
		str2 := os.Args[2]
		for i := 0; i < len(str1); i++ {
			for j := 0; j < len(str2); j++ {
				if str2[j] == str1[i] {
					doesNotExist := true
					for k := range answer {
						if str1[i] == answer[k] {
							doesNotExist = false // str1[k] = 0
						}
					}
					if doesNotExist {
						answer += string(str1[i])
					}
				}
				
			}
		}
		fmt.Println(answer)
	} else {
		fmt.Println()
	}
}
_________________________________
11)func SwapBits(octet byte) byte {
	return ((octet&0x0F)<<4 | (octet&0xF0)>>4)
}
_________________________________
func SwapBits(octet byte) byte {
	var div, mod byte

	div = octet / 16
	mod = octet % 16
	return mod*16 + div
}
