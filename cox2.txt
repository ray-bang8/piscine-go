    14)func REPEATALPHA() {
    	arg := os.Args
    	count := 0
    	if len(arg) == 2 {

    		arr := []rune(arg[1])
    		for i := 0; i < len(arr); i++ {

    			if arr[i] >= 'a' && arr[i] <= 'z' || arr[i] >= 'A' && arr[i] <= 'Z' {

    				if arr[i] >= 'a' && arr[i] <= 'z' {
    					count = int(arr[i]-'a') + 1
    				}

    				if arr[i] >= 'A' && arr[i] <= 'Z' {
    					count = int(arr[i]-'A') + 1
    				}
    				for ; count > 0; count-- {
    					z01.PrintRune(arr[i])
    				}
    			}
    		}
    		z01.PrintRune('\n')
    	} else {
    		z01.PrintRune('\n')
    	}
    }
    _____________________________________
    15)func SortWordArr(str []string) {

    	for i := 0; i < len(str); i++ {
    		for j := i + 1; j < len(str); j++ {
    			if str[i] > str[j] {
    				str[i], str[j] = str[j], str[i]
    			}
    		}
    	}

    }
    func main() {
    	result := []string{"a", "A", "1", "b", "B", "2", "c", "C", "3"}
    	SortWordArr(result)

    	fmt.Println(result)
    }
    _______________________________________
    16)func PRINTHEX() {
    	arg := os.Args
    	if len(arg) == 2 {
    		n := Atoi(arg[1])
    		if n == 0 {
    			z01.PrintRune(0)
    		}
    		var arr [70]rune
    		i := 0
    		for n != 0 {
    			if n < 0 {
    				z01.PrintRune('-')
    				n = n / -1
    			}
    			temp := n % 16
    			if temp < 10 {
    				arr[i] = rune(temp + 48)
    				i++
    			} else {
    				arr[i] = rune(temp + 87)
    				i++
    			}
    			n = n / 16
    		}
    		for j := i - 1; j >= 0; j-- {
    			z01.PrintRune(arr[j])
    		}
    		z01.PrintRune('\n')

    	} else {
    		z01.PrintRune('\n')
    	}

    }
    func Atoi(s string) int {
    	len := 0
    	for range s {
    		len++
    	}
    	meow := []rune(s)
    	final := 0
    	plus := 0
    	minus := 0
    	num := 0
    	for i := 0; i < len; i++ {
    		if meow[i] >= '0' && meow[i] <= '9' {
    			num = 0
    			for j := '0'; j < meow[i]; j++ {
    				num++
    			}
    			final = final*10 + num
    		} else if meow[i] == '+' && i == 0 {
    			plus++
    		} else if meow[i] == '-' && i == 0 {
    			minus++

    		} else {
    			return 0
    		}
    	}
    	if minus == 1 {
    		final = -final
    	}
    	return final
    }
    ______________________
    17)func GCD()
    if len(os.Args) == 3 {


    		s1 := os.Args[1]
    		s2 := os.Args[2]
    		fmt.Println(gcd(Atoi(os.Args[1]), Atoi(os.Args[2])))

    	} else {
    		z01.PrintRune('\n')
    	}
    }
    func gcd(a, b int) int {
    	if b == 0 {
    		return a
    	}
    	return gcd(b, a%b)
    }
    func Atoi(s string) int {
    	min := 0
    	plu := 0
    	sum := 0
    	for i, v := range s {
    		if v >= '0' && v <= '9' {
    			num := 0
    			for j := '0'; j < v; j++ {
    				num++
    			}
    			sum = sum*10 + num
    		} else if v == '-' && i == 0 {
    			min++
    		} else if v == '+' && i == 0 {
    			plu++
    		} else {
    			return 0
    		}

    	}
    	if min == 1 {
    		sum = -sum
    	}
    	return sum
    }
    __________________________________________
    18)func HIDEDENP() {
    	if len(os.Args) == 3 {
    		answer := ""
    		s1 := []rune(os.Args[1])
    		s2 := []rune(os.Args[2])
    		j := 0

    		for i := 0; i < len(s1); i++ {
    			for ; j < len(s2); j++ {
    				if s1[i] == s2[j] {
    					answer += string(s1[i])
    					break
    				}
    			}
    		}
    		fmt.Println(answer)
    		if answer == string(s1) {
    			fmt.Println("1")
    		} else {
    			fmt.Println("0")
    		}
    	} else {
    		fmt.Println()
    	}
    }
    __________________________________________
    19)func ROSTRING() {

    	new := ""
    	new2 := ""
    	if len(os.Args) == 2 {
    		str := os.Args[1]
    		for i := 0; i < len(str); i++ {
    			str = standart(str)
    			if str[0] != 32 {
    				for v := 0; v < len(str); v++ {

    					if str[v] == 32 {
    						new = str[:v]
    						new2 = str[v:]
    						str = new2 + " " + new
    						fmt.Println(standart(str))
    						return
    					}
    				}
    			} 
    		}
    	} else {
    		fmt.Println()
    	}
    }
    func standart(s string) string {
    	return strings.Join(strings.Fields(strings.TrimSpace(s)), " ")
    }
    ____________________________________________
    20)func Split(str, charset string) []string {
		if charset == "" {
			ar := make([]string, len(str))
			i := 0
			for _, v := range str {
				ar[i] = string(v)
				i++
			}
			return ar
		}
	
		nw := 0
		a := 0
		for i := 0; i <= len(str)-len(charset); i++ {
			if str[i:i+len(charset)] == charset {
				a++
				i = i + len(charset)
			}
		}
		ar := make([]string, a+1)
		j := 0
		for i := 0; i <= len(str)-len(charset); i++ {
			if str[i:i+len(charset)] == charset {
				ar[j] = str[nw:i]
				j++
				nw = i + len(charset)
				i = i + len(charset)
			}
		}
		ar[j] = str[nw:]
		return ar
	}
    _________________________________
    21)func REVWSTR() {

    	if len(os.Args) == 2 {
    		str := SplitWhiteSpaces(os.Args[1])
    		for i := len(str) - 1; i >= 0; i-- {
    			fmt.Print(string(str[i]) + " ")
    		}
    		fmt.Println()
    	} else {
    		fmt.Println()
    	}
    }
    func SplitWhiteSpaces(str string) []string {
    	size := 1
    	var result []string
    	lenstr := 0
    	for i := range str {
    		lenstr = i + 1
    	}

    	for i := 0; i < lenstr-1; i++ {
    		if str[i] == ' ' || str[i] == '\t' || str[i] == '\n' {
    			size++
    			if i > 0 {
    				if str[i-1] == ' ' || str[i-1] == '\t' || str[i-1] == '\n' {
    					size--
    				}
    			}
    		}
    	}

    	result = make([]string, size)

    	tempstr := ""
    	j := 0
    	for i := 0; i <= lenstr; i++ {
    		if i == lenstr {
    			if tempstr != "" {
    				result[j] = tempstr
    			}
    		} else if str[i] != ' ' && str[i] != '\t' && str[i] != '\n' {
    			tempstr = tempstr + string(str[i])
    		} else {
    			if tempstr != "" {
    				result[j] = tempstr
    				j++
    			}
    			tempstr = ""
    		}
    	}
    	return result
    }
    _________________________________
    22)func FPRIME() {
    	if len(os.Args) == 2 {
    		v := Atoi(os.Args[1])
    		count := 0
    		l := append(PF(v))
    		for i := 0; i < len(l); i++ {
    			count++
    			if count >= i && i > 0 {
    				fmt.Print("*")
    			}
    			fmt.Print(l[i])
    		}
    		fmt.Println()
    	} else {
    		fmt.Println()
    	}
    }
    func PF(x int) []rune {
    	f := []rune{}
    	c := 2
    	for c <= x {
    		if x%c == 0 {
    			f = append(f, rune(c))
    			x = x / c
    		} else {
    			c++
    		}

    	}
    	return f
    }
    func Atoi(s string) int {
    	min := 0
    	plu := 0
    	res := 0
    	for i, v := range s {
    		if v >= '0' && v <= '9' {
    			num := 0
    			for g := '0'; g < v; g++ {
    				num++
    			}
    			res = res*10 + num
    		} else if v == '-' && i == 0 {
    			min++
    		} else if v == '+' && i == 0 {
    			plu++
    		} else {
    			return 0
    		}
    	}
    	if min == 1 {
    		res = -res
    	}
    	return res
    }
    _________________________________
    23)func ADDPRIMESUM() {

    	if len(os.Args) == 2 {
    		nbr := Atoi(os.Args[1])
    		printPrime(nbr)

    	} else {
    		fmt.Println("0")
    	}
    }

    func IsPrime(value int) bool {
    	if value <= 1 {
    		return false
    	}
    	for i := 2; i < value; i++ {
    		if value%i == 0 {
    			return false
    		}
    	}
    	return true
    }

    func printPrime(n int) int {
    	sum := 0
    	for i := 2; i <= n; i++ {
    		if IsPrime(i) {
    			sum += i

    			//fmt.Println(sum)
    		}

    	}
    	fmt.Println(sum)
    	return sum
    }
    func Atoi(s string) int {
    	min := 0
    	plu := 0
    	res := 0
    	for i, v := range s {
    		if v >= '0' && v <= '9' {
    			num := 0
    			for g := '0'; g < v; g++ {
    				num++
    			}
    			res = res*10 + num
    		} else if v == '-' && i == 0 {
    			min++
    		} else if v == '+' && i == 0 {
    			plu++
    		} else {
    			return 0
    		}
    	}
    	if min == 1 {
    		res = -res
    	}
    	return res
    }
    ________________________________
    24)func AtoiBase(s string, base string) int {

    	indx := 0
    	for _, res := range base {
    		if string(res) == "-" || string(res) == "+" || strings.Count(base, string(res)) > 1 { //nao pode ser menos de 2 numeros a base e nao aceita +-
    			indx = 1
    			break
    		}

    	}
    	if indx == 1 || len(base) < 2 { //se for menos de 2 a base, retorna zero
    		return 0
    	} else {
    		result := 0
    		for i, res := range s {
    			ind := strings.Index(base, string(res))
    			result += ind * RecursivePower(len(base), len(s)-1-i)
    		}
    		return result
    	}
    }

    func Index(s string, toFind string) int {
    	newstr := []rune(s)
    	nb := StrLox(s)
    	strFind := []rune(toFind)
    	nbFind := StrLox(toFind)
    	match := 0
    	index := 0
    	if nbFind == 0 {
    		return 0
    	}
    	for i := 0; i < nbFind; i++ {
    		for j := index; j < nb; j++ {
    			match = 0
    			if strFind[i] == newstr[j] {
    				match = 1
    				index = j
    				break
    			}

    		}
    		if match == 0 {
    			return -1
    		}
    	}
    	return index - nbFind + 1
    }
    func StrLox(s string) int {
    	m := 0
    	for range s {
    		m++
    	}
    	return m

    }
    func RecursivePower(nb int, power int) int {

    	if power < 0 || power > 20 {
    		return 0
    	} else {
    		if power > 0 && power <= 20 {
    			return nb * RecursivePower(nb, power-1)
    		} else if power == 0 {
    			return 1
    		}
    	}
    	return nb
    }
    _________________________________
    25)func Itoa(nbr int) string {
    	result = ""
    	t := 1

    	if nbr < 0 {
    		result += "-"
    		t = -1
    	}
    	if nbr != 0 {
    		q := (nbr / 10) * t
    		if q != 0 {
    			Itoa(q)
    		}
    		d := ((nbr % 10) * t) + '0'
    		result += string(rune(d))
    	} else {
    		result += "0"
    	}

    	return result
    }
    ____________________________
    26)func PrintMemory(arr [10]int) {
    	index := 0
    	for i := 0; i < len(arr); i++ {
    		index++
    		if index == 5 || index == 9 {
    			fmt.Println()
    		}

    		if arr[i] != 0 {
    			// PrintNbrBase(arr[i],"0123456789ABCDEF")
    			dec2hexa(arr[i])
    			fmt.Print("00 0000 ")
    		} else {
    			fmt.Println("0000 0000")
    		}

    	}

    }

    func dec2hexa(n int) {
    	var arr [100]rune
    	i := 0
    	for n != 0 {
    		temp := n % 16
    		if temp < 10 {
    			arr[i] = rune(temp + 48)
    			i++
    		} else {
    			arr[i] = rune(temp + 87)
    			i++
    		}
    		n = n / 16
    	}
    	for j := i - 1; j >= 0; j-- {
    		z01.PrintRune(arr[j])
    	}
    }
    _________________________________
    28)func BRACKEts() {
    	if len(os.Args) == 1 {
    		z01.PrintRune('\n')
    		return
    	}

    	for i := 1; i < len(os.Args); i++ {
    		arr := []rune(os.Args[i])
    		var stack []rune

    		if os.Args[i] == "" {
    			PrintStr("OK")
    			z01.PrintRune('\n')
    		} else {
    			for j := 0; j < StrLen(os.Args[i]); j++ {
    				if arr[j] == '(' || arr[j] == '[' || arr[j] == '{' {
    					stack = append(stack, arr[j])
    				} else {
    					switch arr[j] {
    					case ')':
    						if stack[len(stack)-1] == '(' {
    							stack = stack[0 : len(stack)-1]

    						}
    					case ']':
    						if stack[len(stack)-1] == '[' {
    							stack = stack[0 : len(stack)-1]

    						}
    					case '}':
    						if stack[len(stack)-1] == '{' {
    							stack = stack[0 : len(stack)-1]
    						}
    					}
    				}
    			}

    			if len(stack) == 0 {
    				PrintStr("OK")
    				z01.PrintRune('\n')
    			} else {
    				PrintStr("Error")
    				z01.PrintRune('\n')
    			}

    		}
    	}
    }
    func PrintStr(str string) {

    	stringi := []rune(str)

    	for _, letter := range stringi {

    		z01.PrintRune(letter)
    	}

    }
    func StrLen(str string) int {
    	m := 0
    	for range str {
    		m++
    	}
    	return m
    }
    _____________________-
    29)func ListSize(l *List) int {

    	n := l.Head
    	size := 0
    	for n != nil {
    		size++
    		n = n.Next
    	}
    	return size
	}
	30)func options()
	func ErrorHandle(i int) {
		switch i {
		case 0:
			fmt.Println("options: abcdefghijklmnopqrstuvwxyz")
		case 1:
			fmt.Println("Invalid Option")
		}
	}
	
	func Replace(r rune, pattern string) string {
		index := 0
		res := ""
		sample := "******zy xwvutsrq ponmlkji hgfedcba"
		for i, v := range sample {
			if r == v {
				index = i
			}
		}
		for j, k := range pattern {
			if j == index {
				k = '1'
			}
			res = res + string(k)
		}
		return res
	}
	
	func main() {
		arg := os.Args[1:]
		pattern := "00000000 00000000 00000000 00000000"
		var flag bool
		if len(arg) < 1 {
			ErrorHandle(0)
		}
		for _, vv := range arg {
			for i, v := range vv {
				if i == 0 && v == '-' {
					flag = true
				}
				if vv[i] == '-' && vv[i+1] == 'h' && i < len(vv) {
					ErrorHandle(0)
					return
				}
				if flag {
					if v >= 'a' && v <= 'z' {
						res := Replace(v, pattern)
						pattern = res
					} else if v == '-' {
					} else {
						ErrorHandle(1)
						return
					}
				}
			}
		}
		fmt.Println(pattern)
	}
    _________________________________
    31)func ListRemoveIf(l *List, data_ref interface{}) {
    	temp := l.Head
    	prev := l.Head

    	for temp != nil && temp.Data == data_ref {
    		l.Head = temp.Next
    		temp = l.Head
    	}
    	for temp != nil {
    		for temp != nil && temp.Data != data_ref {
    			prev = temp
    			temp = temp.Next
    		}

    		if temp == nil {
    			return
    		}
    		prev.Next = temp.Next
    		temp = prev.Next
    	}
    }
    ________________________________

    32)func ItoaBase(value, base int) string {
    	newbase := "0123456789ABCDEF"
    	newbase = newbase[0:base]
    	result := ConvertFromDecimal(value, newbase)
    	return result
	}
	33)func AddLinkedNumbers(num1, num2 *NodeAddL) *NodeAddL {

		res := ListToInt(num1) + ListToInt(num2)
		str := strconv.Itoa(res)
		firstDigit := int(str[len(str)-1] - 48)
		list := &NodeAddL{Num: firstDigit}
		for i := len(str) - 2; i >= 0; i-- {
			list = pushFront(list, int(str[i]-48))
		}
		return list
	}
	
	func ListToInt(num *NodeAddL) int {
		str := ""
		current := num
		for current != nil {
			str += strconv.Itoa(current.Num)
			current = current.Next
		}
		nbr, _ := strconv.Atoi(str)
		return nbr
	}
	
	func pushFront(node *NodeAddL, num int) *NodeAddL {
		a := &NodeAddL{
			Num:  num,
			Next: node,
		}
		return a
	}
	
	type NodeAddL struct {
		Next *NodeAddL
		Num  int
	}
    __________________________________-
    34)func BRAINFUCK() {

    	if len(os.Args) == 1 {
    		fmt.Println()
    		return
    	}

    	arr := make([]byte, 2048)
    	p := &arr[0]
    	arg := []rune(os.Args[1])

    	i := 0
    	j := 0

    	for j < 2048 {
    		for i < len(arg) {
    			switch arg[i] {
    			case '>':
    				j++
    				p = &arr[j]
    			case '<':
    				j--
    				p = &arr[j]
    			case '+':
    				*p++
    			case '-':
    				*p--
    			case '.':
    				fmt.Println(string(*p))
    			case '[':
    				cont := 0

    				if *p == 0 {

    					for cont >= 0 {
    						i++
    						if arg[i] == ']' {
    							cont--
    						} else if arg[i] == '[' {
    							cont++
    						}
    					}
    				}
    			case ']':
    				cont := 0
    				if *p != 0 {
    					for cont >= 0 {
    						i--
    						if arg[i] == '[' {
    							cont--
    						} else if arg[i] == ']' {
    							cont++
    						}
    					}
    				}
    			}

    			i++
    		}
    		j = 2048
		}
	35)func Anagram(str1, str2 string) bool {

		if CountLen(str1) != CountLen(str2) {
			return false
		}
	
		newarg := make([]rune, CountLen(str2))
		j := 0
		for _, two := range str2 {
			if two != ' ' {
				newarg[j] = two
				j++
			}
		}
	
		count := 0
		for _, one := range str1 {
			for j, two := range newarg {
				if one == two {
					count++
					newarg[j] = '#'
					break
				}
			}
		}
		fmt.Println(string(newarg))
		return CountLen(str2) == count
	
	}
	
	func CountLen(str string) int {
	
		counter := 0
	
		for _, x := range str {
			if x >= 'a' && x <= 'z' {
				counter++
			}
		}
		return counter
	}
	36)func balancedstring() {
		input := os.Args[1:]
		if len(input) != 1 {
			fmt.Println()
			return
		}
		count := 0
		bims := 0
		for _, val := range input[0] {
			if val == 'C' {
				count++
			} else {
				count--
			}
			if count == 0 {
				bims++
			}
		}
		fmt.Println(bims)
	}
	38)type TNode struct {
		Val   int
		Left  *TNode
		Right *TNode
	}
	
	func InvertTree(root *TNode) *TNode {
		// проверка есть ли потомки
		if root == nil {
			return nil
		}
	
		// заносим во временную переменную левую ветку
		var t *TNode
		t = root.Left
		// рекурсивно вызываем для каждой подветки, т.е. слева(правое) справа(левое)
		root.Left = InvertTree(root.Right)
		fmt.Println("root.Left", root.Left)
		root.Right = InvertTree(t)
		return root
	}
	
	func BTreeInsertData(root *TNode, val int) *TNode {
	
		if root == nil {
			return &TNode{Val: val}
		}
	
		if val < root.Val {
			root.Left = BTreeInsertData(root.Left, val)
		} else {
			root.Right = BTreeInsertData(root.Right, val)
		}
		return root
	}
	
	func BTreeApplyInOrder(root *TNode, f func(...interface{}) (int, error)) {
	
		if root == nil {
			return
		}
		BTreeApplyInOrder(root.Left, f)
		f(root.Val)
		BTreeApplyInOrder(root.Right, f)
	}
	39)func Lcm(first, second int) int {
		n1 := first
		n2 := second
		var res int
		i := 1
		for i >= 1 {
			temp := i * n2
			if temp%n1 == 0 && temp%n2 == 0 {
				res = temp
				break
			}
			i++
	
		}
		return res
	
	}
	41)func Nauuo(a, b, c int) string {
		str := ""
		if a > (b + c) {
			str = "+"
		} else if b > (a + c) {
			str = "-"
		} else if a == b && c == 0 {
			str = "0"
		} else {
			str = "?"
		}
	
		return str
	}
	43)func printchessboard() {
		if len(os.Args[1:]) != 2 {
			PrintErr()
			return
		} else {
			col, e := strconv.Atoi(os.Args[1])
			line, er := strconv.Atoi(os.Args[2])
			if e != nil || er != nil {
				PrintErr()
				return
			}
	
			for l := 1; l <= line; l++ {
				for c := 1; c <= col; c++ {
					if (isOdd(c) && isOdd(l)) || (!isOdd(c) && !isOdd(l)) {
						z01.PrintRune('#')
					} else {
						z01.PrintRune(' ')
					}
				}
				z01.PrintRune('\n')
			}
	
		}
	}
	func isOdd(n int) bool {
		if n%2 == 0 {
			return false
		}
		return true
	}
	45)func robottoorigin() {
		args := os.Args[1:]
		var UD int
		var RL int
		var f string
		for _, v := range args[0] {
			if v == 'U' {
				UD++
			} else if v == 'D' {
				UD--
			} else if v == 'R' {
				RL++
			} else if v == 'L' {
				RL--
			}
	
			if UD == 0 && RL == 0 {
				f = "true"
			} else {
				f = "false"
			}
		}
	
		for _, v := range f {
			z01.PrintRune(v)
		}
		z01.PrintRune('\n')
	}
	48)func TwoSum(nums []int, target int) []int {

		a := []int{0, 0}
		for i, v := range nums {
			for j, g := range nums {
				if v+g == target && i != j {
					a[0] = j
					a[1] = i
					return a
				}
			}
		}
		return nil
	
	}
	49)func main() {

		arg := os.Args[1:]
	
		if len(arg) == 1 {
			str := arg[0]
			var count int
			var arr []int
			check := true
	
			for len(str) > 0 {
				count, str = counter(rune(str[0]), str)
				arr = append(arr, count)
			}
			for i, v := range arr {
				for j, k := range arr {
					if v == k && i != j {
	
						check = false
						break
					}
				}
	
			}
			fmt.Println(check)
		} else {
			fmt.Println()
		}
	
	}
	func counter(c rune, s string) (int, string) {
		count := 0
		str := ""
		for _, v := range s {
			if v == c {
				count++
	
			} else {
				str = str + string(v)
			}
		}
		return count, str
	}
	func myAppend(arr []string, newString string) []string {
		count := 0
		for range arr {
			count++
		}
	
		newArr := make([]string, count+1)
		for index, element := range arr {
			newArr[index] = element
		}
	
		newArr[count] = newString
		return newArr
	}