    14)func REPEATALPHA() {
    	arg := os.Args
    	count := 0
    	if len(arg) == 2 {

    		arr := []rune(arg[1])
    		for i := 0; i < len(arr); i++ {

    			if arr[i] >= 'a' && arr[i] <= 'z' || arr[i] >= 'A' && arr[i] <= 'Z' {

    				if arr[i] >= 'a' && arr[i] <= 'z' {
    					count = int(arr[i]-'a') + 1
    				}

    				if arr[i] >= 'A' && arr[i] <= 'Z' {
    					count = int(arr[i]-'A') + 1
    				}
    				for ; count > 0; count-- {
    					z01.PrintRune(arr[i])
    				}
    			}
    		}
    		z01.PrintRune('\n')
    	} else {
    		z01.PrintRune('\n')
    	}
    }
    _____________________________________
    15)func SortWordArr(str []string) {

    	for i := 0; i < len(str); i++ {
    		for j := i + 1; j < len(str); j++ {
    			if str[i] > str[j] {
    				str[i], str[j] = str[j], str[i]
    			}
    		}
    	}

    }
    func main() {
    	result := []string{"a", "A", "1", "b", "B", "2", "c", "C", "3"}
    	SortWordArr(result)

    	fmt.Println(result)
    }
    _______________________________________
    16)func PRINTHEX() {
    	arg := os.Args
    	if len(arg) == 2 {
    		n := Atoi(arg[1])
    		if n == 0 {
    			z01.PrintRune(0)
    		}
    		var arr [70]rune
    		i := 0
    		for n != 0 {
    			if n < 0 {
    				z01.PrintRune('-')
    				n = n / -1
    			}
    			temp := n % 16
    			if temp < 10 {
    				arr[i] = rune(temp + 48)
    				i++
    			} else {
    				arr[i] = rune(temp + 87)
    				i++
    			}
    			n = n / 16
    		}
    		for j := i - 1; j >= 0; j-- {
    			z01.PrintRune(arr[j])
    		}
    		z01.PrintRune('\n')

    	} else {
    		z01.PrintRune('\n')
    	}

    }
    func Atoi(s string) int {
    	len := 0
    	for range s {
    		len++
    	}
    	meow := []rune(s)
    	final := 0
    	plus := 0
    	minus := 0
    	num := 0
    	for i := 0; i < len; i++ {
    		if meow[i] >= '0' && meow[i] <= '9' {
    			num = 0
    			for j := '0'; j < meow[i]; j++ {
    				num++
    			}
    			final = final*10 + num
    		} else if meow[i] == '+' && i == 0 {
    			plus++
    		} else if meow[i] == '-' && i == 0 {
    			minus++

    		} else {
    			return 0
    		}
    	}
    	if minus == 1 {
    		final = -final
    	}
    	return final
    }
    ______________________
    17)func GCD()
    if len(os.Args) == 3 {


    		s1 := os.Args[1]
    		s2 := os.Args[2]
    		fmt.Println(gcd(Atoi(os.Args[1]), Atoi(os.Args[2])))

    	} else {
    		z01.PrintRune('\n')
    	}
    }
    func gcd(a, b int) int {
    	if b == 0 {
    		return a
    	}
    	return gcd(b, a%b)
    }
    func Atoi(s string) int {
    	min := 0
    	plu := 0
    	sum := 0
    	for i, v := range s {
    		if v >= '0' && v <= '9' {
    			num := 0
    			for j := '0'; j < v; j++ {
    				num++
    			}
    			sum = sum*10 + num
    		} else if v == '-' && i == 0 {
    			min++
    		} else if v == '+' && i == 0 {
    			plu++
    		} else {
    			return 0
    		}

    	}
    	if min == 1 {
    		sum = -sum
    	}
    	return sum
    }
    __________________________________________
    18)func HIDEDENP() {
    	if len(os.Args) == 3 {
    		answer := ""
    		s1 := []rune(os.Args[1])
    		s2 := []rune(os.Args[2])
    		j := 0

    		for i := 0; i < len(s1); i++ {
    			for ; j < len(s2); j++ {
    				if s1[i] == s2[j] {
    					answer += string(s1[i])
    					break
    				}
    			}
    		}
    		fmt.Println(answer)
    		if answer == string(s1) {
    			fmt.Println("1")
    		} else {
    			fmt.Println("0")
    		}
    	} else {
    		fmt.Println()
    	}
    }
    __________________________________________
    19)func ROSTRING() {

    	new := ""
    	new2 := ""
    	if len(os.Args) == 2 {
    		str := os.Args[1]
    		for i := 0; i < len(str); i++ {
    			str = standart(str)
    			if str[0] != 32 {
    				for v := 0; v < len(str); v++ {

    					if str[v] == 32 {
    						new = str[:v]
    						new2 = str[v:]
    						str = new2 + " " + new
    						fmt.Println(standart(str))
    						return
    					}
    				}
    			} 
    		}
    	} else {
    		fmt.Println()
    	}
    }
    func standart(s string) string {
    	return strings.Join(strings.Fields(strings.TrimSpace(s)), " ")
    }
    ____________________________________________
    20)func SPLITPROG() {
    	if len(os.Args) == 3 {
    		s := Split(os.Args[1], os.Args[2])
    		fmt.Println(s)
    	} else {
    		fmt.Println()
    	}
    }

    func Split(s1, s2 string) []string {
    	resp := []string{}
    	new := ""
    	for i := 0; i < len(s1); i++ {
    		if Check(s1, s2, i) {
    			if new != "" {
    				resp = append(resp, new)
    				new = ""
    				i = i + len(s2) - 1
    			}
    		} else {
    			new = new + string(s1[i])
    		}
    	}
    	if new != "" {
    		resp = append(resp, new)
    	}
    	return resp
    }
    func Check(s1, s2 string, i int) bool {
    	j := 0
    	for j < len(s1) && j < len(s2) {
    		if s1[i] != s2[j] {
    			return false
    		}
    		i++
    		j++
    	}
    	return true
    }
    _________________________________
    21)func REVWSTR() {

    	if len(os.Args) == 2 {
    		str := SplitWhiteSpaces(os.Args[1])
    		for i := len(str) - 1; i >= 0; i-- {
    			fmt.Print(string(str[i]) + " ")
    		}
    		fmt.Println()
    	} else {
    		fmt.Println()
    	}
    }
    func SplitWhiteSpaces(str string) []string {
    	size := 1
    	var result []string
    	lenstr := 0
    	for i := range str {
    		lenstr = i + 1
    	}

    	for i := 0; i < lenstr-1; i++ {
    		if str[i] == ' ' || str[i] == '\t' || str[i] == '\n' {
    			size++
    			if i > 0 {
    				if str[i-1] == ' ' || str[i-1] == '\t' || str[i-1] == '\n' {
    					size--
    				}
    			}
    		}
    	}

    	result = make([]string, size)

    	tempstr := ""
    	j := 0
    	for i := 0; i <= lenstr; i++ {
    		if i == lenstr {
    			if tempstr != "" {
    				result[j] = tempstr
    			}
    		} else if str[i] != ' ' && str[i] != '\t' && str[i] != '\n' {
    			tempstr = tempstr + string(str[i])
    		} else {
    			if tempstr != "" {
    				result[j] = tempstr
    				j++
    			}
    			tempstr = ""
    		}
    	}
    	return result
    }
    _________________________________
    22)func FPRIME() {
    	if len(os.Args) == 2 {
    		v := Atoi(os.Args[1])
    		count := 0
    		l := append(PF(v))
    		for i := 0; i < len(l); i++ {
    			count++
    			if count >= i && i > 0 {
    				fmt.Print("*")
    			}
    			fmt.Print(l[i])
    		}
    		fmt.Println()
    	} else {
    		fmt.Println()
    	}
    }
    func PF(x int) []rune {
    	f := []rune{}
    	c := 2
    	for c <= x {
    		if x%c == 0 {
    			f = append(f, rune(c))
    			x = x / c
    		} else {
    			c++
    		}

    	}
    	return f
    }
    func Atoi(s string) int {
    	min := 0
    	plu := 0
    	res := 0
    	for i, v := range s {
    		if v >= '0' && v <= '9' {
    			num := 0
    			for g := '0'; g < v; g++ {
    				num++
    			}
    			res = res*10 + num
    		} else if v == '-' && i == 0 {
    			min++
    		} else if v == '+' && i == 0 {
    			plu++
    		} else {
    			return 0
    		}
    	}
    	if min == 1 {
    		res = -res
    	}
    	return res
    }
    _________________________________
    23)func ADDPRIMESUM() {

    	if len(os.Args) == 2 {
    		nbr := Atoi(os.Args[1])
    		printPrime(nbr)

    	} else {
    		fmt.Println("0")
    	}
    }

    func IsPrime(value int) bool {
    	if value <= 1 {
    		return false
    	}
    	for i := 2; i < value; i++ {
    		if value%i == 0 {
    			return false
    		}
    	}
    	return true
    }

    func printPrime(n int) int {
    	sum := 0
    	for i := 2; i <= n; i++ {
    		if IsPrime(i) {
    			sum += i

    			//fmt.Println(sum)
    		}

    	}
    	fmt.Println(sum)
    	return sum
    }
    func Atoi(s string) int {
    	min := 0
    	plu := 0
    	res := 0
    	for i, v := range s {
    		if v >= '0' && v <= '9' {
    			num := 0
    			for g := '0'; g < v; g++ {
    				num++
    			}
    			res = res*10 + num
    		} else if v == '-' && i == 0 {
    			min++
    		} else if v == '+' && i == 0 {
    			plu++
    		} else {
    			return 0
    		}
    	}
    	if min == 1 {
    		res = -res
    	}
    	return res
    }
    ________________________________
    24)func AtoiBase(s string, base string) int {

    	indx := 0
    	for _, res := range base {
    		if string(res) == "-" || string(res) == "+" || strings.Count(base, string(res)) > 1 { //nao pode ser menos de 2 numeros a base e nao aceita +-
    			indx = 1
    			break
    		}

    	}
    	if indx == 1 || len(base) < 2 { //se for menos de 2 a base, retorna zero
    		return 0
    	} else {
    		result := 0
    		for i, res := range s {
    			ind := strings.Index(base, string(res))
    			result += ind * RecursivePower(len(base), len(s)-1-i)
    		}
    		return result
    	}
    }

    func Index(s string, toFind string) int {
    	newstr := []rune(s)
    	nb := StrLox(s)
    	strFind := []rune(toFind)
    	nbFind := StrLox(toFind)
    	match := 0
    	index := 0
    	if nbFind == 0 {
    		return 0
    	}
    	for i := 0; i < nbFind; i++ {
    		for j := index; j < nb; j++ {
    			match = 0
    			if strFind[i] == newstr[j] {
    				match = 1
    				index = j
    				break
    			}

    		}
    		if match == 0 {
    			return -1
    		}
    	}
    	return index - nbFind + 1
    }
    func StrLox(s string) int {
    	m := 0
    	for range s {
    		m++
    	}
    	return m

    }
    func RecursivePower(nb int, power int) int {

    	if power < 0 || power > 20 {
    		return 0
    	} else {
    		if power > 0 && power <= 20 {
    			return nb * RecursivePower(nb, power-1)
    		} else if power == 0 {
    			return 1
    		}
    	}
    	return nb
    }
    _________________________________
    25)func Itoa(nbr int) string {
    	result = ""
    	t := 1

    	if nbr < 0 {
    		result += "-"
    		t = -1
    	}
    	if nbr != 0 {
    		q := (nbr / 10) * t
    		if q != 0 {
    			Itoa(q)
    		}
    		d := ((nbr % 10) * t) + '0'
    		result += string(rune(d))
    	} else {
    		result += "0"
    	}

    	return result
    }
    ____________________________
    26)func PrintMemory(arr [10]int) {
    	index := 0
    	for i := 0; i < len(arr); i++ {
    		index++
    		if index == 5 || index == 9 {
    			fmt.Println()
    		}

    		if arr[i] != 0 {
    			// PrintNbrBase(arr[i],"0123456789ABCDEF")
    			dec2hexa(arr[i])
    			fmt.Print("00 0000 ")
    		} else {
    			fmt.Println("0000 0000")
    		}

    	}

    }

    func dec2hexa(n int) {
    	var arr [100]rune
    	i := 0
    	for n != 0 {
    		temp := n % 16
    		if temp < 10 {
    			arr[i] = rune(temp + 48)
    			i++
    		} else {
    			arr[i] = rune(temp + 87)
    			i++
    		}
    		n = n / 16
    	}
    	for j := i - 1; j >= 0; j-- {
    		z01.PrintRune(arr[j])
    	}
    }
    _________________________________
    28)func BRACKEts() {
    	if len(os.Args) == 1 {
    		z01.PrintRune('\n')
    		return
    	}

    	for i := 1; i < len(os.Args); i++ {
    		arr := []rune(os.Args[i])
    		var stack []rune

    		if os.Args[i] == "" {
    			PrintStr("OK")
    			z01.PrintRune('\n')
    		} else {
    			for j := 0; j < StrLen(os.Args[i]); j++ {
    				if arr[j] == '(' || arr[j] == '[' || arr[j] == '{' {
    					stack = append(stack, arr[j])
    				} else {
    					switch arr[j] {
    					case ')':
    						if stack[len(stack)-1] == '(' {
    							stack = stack[0 : len(stack)-1]

    						}
    					case ']':
    						if stack[len(stack)-1] == '[' {
    							stack = stack[0 : len(stack)-1]

    						}
    					case '}':
    						if stack[len(stack)-1] == '{' {
    							stack = stack[0 : len(stack)-1]
    						}
    					}
    				}
    			}

    			if len(stack) == 0 {
    				PrintStr("OK")
    				z01.PrintRune('\n')
    			} else {
    				PrintStr("Error")
    				z01.PrintRune('\n')
    			}

    		}
    	}
    }
    func PrintStr(str string) {

    	stringi := []rune(str)

    	for _, letter := range stringi {

    		z01.PrintRune(letter)
    	}

    }
    func StrLen(str string) int {
    	m := 0
    	for range str {
    		m++
    	}
    	return m
    }
    _____________________-
    29)func ListSize(l *List) int {

    	n := l.Head
    	size := 0
    	for n != nil {
    		size++
    		n = n.Next
    	}
    	return size
    }
    _________________________________
    31)func ListRemoveIf(l *List, data_ref interface{}) {
    	temp := l.Head
    	prev := l.Head

    	for temp != nil && temp.Data == data_ref {
    		l.Head = temp.Next
    		temp = l.Head
    	}
    	for temp != nil {
    		for temp != nil && temp.Data != data_ref {
    			prev = temp
    			temp = temp.Next
    		}

    		if temp == nil {
    			return
    		}
    		prev.Next = temp.Next
    		temp = prev.Next
    	}
    }
    ________________________________

    32)func ItoaBase(value, base int) string {
    	newbase := "0123456789ABCDEF"
    	newbase = newbase[0:base]
    	result := ConvertFromDecimal(value, newbase)
    	return result
    }
    __________________________________-
    34)func BRAINFUCK() {

    	if len(os.Args) == 1 {
    		fmt.Println()
    		return
    	}

    	arr := make([]byte, 2048)
    	p := &arr[0]
    	arg := []rune(os.Args[1])

    	i := 0
    	j := 0

    	for j < 2048 {
    		for i < len(arg) {
    			switch arg[i] {
    			case '>':
    				j++
    				p = &arr[j]
    			case '<':
    				j--
    				p = &arr[j]
    			case '+':
    				*p++
    			case '-':
    				*p--
    			case '.':
    				fmt.Println(string(*p))
    			case '[':
    				cont := 0

    				if *p == 0 {

    					for cont >= 0 {
    						i++
    						if arg[i] == ']' {
    							cont--
    						} else if arg[i] == '[' {
    							cont++
    						}
    					}
    				}
    			case ']':
    				cont := 0
    				if *p != 0 {
    					for cont >= 0 {
    						i--
    						if arg[i] == '[' {
    							cont--
    						} else if arg[i] == ']' {
    							cont++
    						}
    					}
    				}
    			}

    			i++
    		}
    		j = 2048
    	}